package config;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;
import org.apache.commons.codec.binary.Base64;

public class Hasher {
    
    private Hasher(){
        
    }
    /**
     * Computes the hashing of the specified password with a salt of length 256, using
     * the specified algorithm.
     * @param password The password to hash
     * @param algorithm The digestion algorithm to be used
     * @return An instance of {@link HashedPair} with the processed data
     * @throws java.security.NoSuchAlgorithmException 
     * @throws org.apache.ws.commons.util.Base64.DecodingException 
     * @throws java.io.UnsupportedEncodingException 
     */
    public static HashedPair digestPassword(String password, String algorithm) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String[] results = (String[]) doHashingOperation(null, password, null, algorithm);
        return new HashedPair(results[0], results[1]);
    }
    /**
     * Hashes the specified {@code inputPassword} using the specified algorithm with the
     * specified salt. Then it verifies that the resulting hash matches the specified
     * {@code storedPassword}
     * @param salt Random bytes used to salt the hashing
     * @param inputPassword The password that should be hashed
     * @param storedPassword The password to match the hashed string against
     * @param algorithm The digestion algorithm to be used
     * @return {@code true} When the passwords match, {@code false} otherwise
     * @throws org.apache.ws.commons.util.Base64.DecodingException When the salt string
     * is corrupted
     * @throws NoSuchAlgorithmException When an unknown algorithm is specified
     */
    public static Boolean passwordsMatch(String salt, String inputPassword, String storedPassword, String algorithm) 
            throws NoSuchAlgorithmException, UnsupportedEncodingException {
        return (Boolean)doHashingOperation(salt, inputPassword, storedPassword, algorithm);
    }
    
    private static Object doHashingOperation(String salt, String inputPassword, String storedPassword, String alg) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        byte[] saltBytes;
        
        if (salt != null)
            saltBytes = Base64.decodeBase64(salt);
        else {
            saltBytes = new byte[256];
            new Random().nextBytes(saltBytes);
        }
        MessageDigest md = MessageDigest.getInstance(alg);
        md.update(saltBytes);
        byte[] passwordBytes = md.digest(inputPassword.getBytes("UTF-8"));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < passwordBytes.length; i++)
            sb.append(Integer.toString((passwordBytes[i] & 0xff) + 0x100, 16).substring(1));
        if (storedPassword == null)
            // Nothing to match against, simply return the string hashing and the generated salt
            return new String[]{sb.toString(), Base64.encodeBase64String(saltBytes)};
        // Otherwise return the result of equality comparisson
        return storedPassword.equals(sb.toString());
    }
    
    /**
     * Utility class to temporarily hold the digested credentials
     */
    public static class HashedPair {
        
        /**
         * Password after beign digested by the specified algorithm
         */
        private final String digestedPassword;
        /**
         * Base64 representation of the randomly generated bytes used to salt the digestion
         */
        private final String b64Salt;
        
        public HashedPair(String password, String salt) {
            this.digestedPassword = password;
            this.b64Salt = salt;
        }

        public String getDigestedPassword() {
            return digestedPassword;
        }

        public String getB64Salt() {
            return b64Salt;
        }
    }
}
